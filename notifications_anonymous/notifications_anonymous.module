<?php
// $Id$
/**
 * @file
 *   Notifications for anonymous users
 */

/**
 * Implementation of hook_menu()
 */
function notifications_anonymous_menu() {
    // Subscribe links. For this items access will be checked later in the page
  $items['notifications/anonymous/subscribe'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'notifications_anonymous_page_subscribe',
    'access callback' => 'notifications_anonymous_subscription_access',
    'access arguments' => array('create'),
    'file' => 'notifications_anonymous.pages.inc',
  );
  // Present form to request subscriptions
  $items['notifications/anonymous/request'] = array (
    'title' => 'Manage subscriptions',
    'page callback' => 'notifications_anonymous_request_page',
    'access callback' => TRUE,
    'file' => 'notifications_anonymous.pages.inc',
    'type' => MENU_CALLBACK,
  );
  // Destination operations
  foreach (array('edit', 'delete', 'manage') as $op) {
    $items['notifications/anonymous/destination/%messaging_destination/' . $op] = array (
      'title' => 'Edit destination',
      'page callback' => 'notifications_anonymous_destination_page',
      'page arguments' => array(3, 4),
      'access callback' => 'notifications_anonymous_destination_access',
      'access arguments' => array(4, 3),
      'file' => 'notifications_anonymous.pages.inc',
      'type' => MENU_CALLBACK,
    );
  }
  // Subscription operations
  foreach (array('edit', 'unsubscribe') as $op) {
    $items['notifications/anonymous/subscription/%notififications_subscription/' . $op] = array (
      'title' => 'Edit subscription',
      'page callback' => 'notifications_anonymous_subscription_page',
      'page arguments' => array(3, 4),
      'access callback' => 'notifications_anonymous_subscription_access',
      'access arguments' => array(4, 3),
      'file' => 'notifications_anonymous.pages.inc',
      'type' => MENU_CALLBACK,
    );
  }
  // Admin settings page
  $items['admin/messaging/notifications/anonymous'] = array(
    'title' => 'Anonymous',
    'description' => 'Settings for anonymous subscriptions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('notifications_anonymous_admin_settings_form'),
    'access arguments' => array('administer notifications'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'notifications_anonymous.pages.inc',
  );
  return $items;
}

/**
 * Menu access callback for subscriptions
 */
function notifications_anonymous_subscription_access($op = 'create', $subscription = NULL) {  
  switch ($op) {
    case 'create':
      return user_access('create anonymous subscriptions') && notifications_anonymous_send_methods();
  }
}

/**
 * Menu access callback for destinations
 */
function notifications_anonymous_destination_access($op, $destination = NULL) {  
  global $user;
  // Access will be granted if anonymous destination or administrator
  if (user_access('administer notifications')) {
    return TRUE;
  }
  elseif (!$destination->uid || $destination->uid == $user->uid) {
    switch ($op) {
      case 'manage':
        return user_access('manage own subscriptions');
      case 'edit':
        return user_access('maintain own subscriptions');
      case 'confirm': 
      case 'delete':
        return TRUE;
    }
  }
}

/**
 * Implementation of hook_block()
 */
function notifications_anonymous_block($op = 'list', $delta = 0) {
  global $user;
  
  if ($op == 'list') {
    $blocks[0]['info'] = t('Anonymous subscription links');
    $blocks[0]['cache'] = BLOCK_NO_CACHE;
    return $blocks;
  }
  else if ($op == 'view' && !$user->uid) {
    if ((arg(0) == 'node') && is_numeric(arg(1)) && ($node = node_load(arg(1))) && notifications_ui_node_options($node->type, 'block')) {
      // Only display if we have something for the form
      if ($node_options = notifications_ui_subscribe_options($user, 'node', $node)) {
        $block['subject'] = t('Subscribe to');
        $block['content'] = drupal_get_form('notifications_ui_options_form', $node_options, FALSE);
        return $block;
      }      
    }
    elseif (arg(0) == 'user' && is_numeric(arg(1)) && notifications_ui_account_options('block')) {
      // Only display if we have something for the form
      if (($account = user_load(arg(1))) && ($options = notifications_ui_subscribe_options($user, 'user', $account))) {
        $block['subject'] = t('Subscribe to');
        $block['content'] = drupal_get_form('notifications_ui_options_form', $options, FALSE);
        return $block;
      }       
    }
  }  
}

/**
 * Get list of possible and existing subscriptions for anonymous user
 * 
 * @param $type
 *   Subscription type to get options: 'user', 'node'
 * @param $object
 *   The object to subscribe. It may be $node or $user
 * 
 * @return
 *   Array of subscription options
 *   The enabled ones will have a 'subscriptions' element loaded
 */
function notifications_anonymous_subscribe_options($type, $object) {
  $account = drupal_anonymous_user();
  // Get allowed node options and current subscriptions
  $subscribe_options = notifications_module_information("$type options", $account, $object);
  $allowed_options = array();
  // Get subscription types checking for user access
  $allowed_types = notifications_subscription_types(NULL, NULL, TRUE);
  // We also keep track of event types for each subscription type
  $event_types = array('node' => TRUE);
  foreach ($subscribe_options as $index => $option) {
    if (isset($allowed_types[$option['type']]) && notifications_user_allowed('subscription', $account, (object)$option)) {
      $allowed_options[] = $option;
      // We add the event type to our list
      $event_types[$allowed_types[$option['type']]['event_type']] = TRUE;
    }
  }
  return $allowed_options;
}

/**
 * Implementation of hook_link()
 * 
 * Add subscriptions links to nodes. Depends on notifications_ui enabled.
 * 
 * @todo Remove dependency on notifications_ui
 */
function notifications_anonymous_link($type, $node = NULL, $teaser = FALSE) {
  global $user;

  if ($type == 'node' && !$user->uid && notifications_anonymous_subscription_access() && module_exists('notifications_ui') &&
    (notifications_ui_node_options($node->type, 'teaserlinks') && $teaser || notifications_ui_node_options($node->type, 'links') && !$teaser)
     && ($options = notifications_ui_subscribe_options($user, 'node', $node))) {
      // Now we have the array of allowed options ready, build single links 
      return notifications_anonymous_build_links($options);
  }
}

/**
 * Build subscription options as an array of links
 * 
 * These links can be added as node link elements or rendered some other way
 * 
 * @param $options
 *   Array of subscription options, like the one produced by notifications_ui_subscribe_options()
 * @param $prefix
 *   Prefix to use for the link indexes
 */
function notifications_anonymous_build_links($options, $prefix = 'notifications_anonymous_') {
  $links = array();  
  foreach ($options as $index => $option) {
    // Subscribe link
    $title = t('Subscribe to: @name', array('@name' => $option['name']));
    $props = notifications_anonymous_get_link('subscribe', array('type' => $option['type'], 'confirm' => TRUE, 'fields' => $option['fields'], 'destination' => TRUE));
    $links[$prefix . $index] = array(
      'title' => $title,
      'html' => TRUE,
      'href' => $props['href'],
    ) + $props['options'];      
  }
  return $links;  
}

/**
 * Get available sending methods for anonymous users
 */
function notifications_anonymous_send_methods() {
  $list = &messaging_static(__FUNCTION__);
  if (!isset($list)) {
    $list = array();
    $allowed = variable_get('notifications_anonymous_send_methods', array());
    foreach (messaging_method_list() as $method => $name) {
      if (in_array($method, $allowed)) {
        $list[$method] = $name;
      }
    }
  }
  return $list;
}

/**
 * Get available send intervals for anonymous users
 */
function notifications_anonymous_send_intervals() {
  $list = &messaging_static(__FUNCTION__);
  if (!isset($list)) {
    $list = array();
    $allowed = variable_get('notifications_anonymous_send_intervals', array());
    foreach (notifications_send_intervals() as $interval => $name) {
      if (in_array($interval, $allowed)) {
        $list[$interval] = $name;
      }
    }
  }
  return $list;
}

/**
 * Implementation of hook_perm()
 */
function notifications_anonymous_perm() {
  return array('create anonymous subscriptions');
}

/**
 * Destination form submitted
 */
function notifications_anonymous_destination_form_submit(&$form, &$form_state) {
  $account = $form_state['values']['account'];
  $method = $form_state['values']['method'];
  $address = $form_state['values']['address'];
  $destination = Messaging_Destination::get(array('method' => $method, 'address' => $address));
  if ($destination) {
    if ($account && $account->uid && $destination->uid == $account->uid) {
      // The address belongs to the current user, so go for it
      notifications_delete_destination($destination->mdid);
      drupal_set_message(t('All the subscriptions for that address have been deleted.'));
      return;
    }
    else {
      // Will ask for confirmation if enabled always or if it belongs to a user
      $confirm = variable_get('notifications_anonymous_unsubscribe_confirm', 1);
      notifications_anonymous_message('unsubscribe', $destination, $confirm || $destination->uid);
    }
  }
  // We print out a message without undisclosing any information about whether the address exists or not
  drupal_set_message(t('If your address is found on this system, a message will be sent with a link to delete all subscriptions.'));
}

/**
 * Implementation of hook_form_alter()
 */
function notifications_anonymous_form_alter(&$form, $form_state, $form_id) {
  global $user;
  
  switch ($form_id) {
    case 'notifications_ui_options_form':
      $account = $form['subscriptions']['account'];
      if (!$account->uid && !$user->uid) {
        notifications_include('destination');
        $form += notifications_destination_address_subform($account);
        //$form['destination']['#weight'] = -10;
      }
      break;
  }
}

/**
 * Implementation of hook_token_values()
 * 
 * Provide user-like tokens for anonymous users
 */
function notifications_anonymous_token_values($type, $object = NULL, $options = array()) {
  switch ($type) {
    case 'user':
      $values = array();
      // Object should have no uid but a valid mdid
      if (($account = $object) && !$object->uid && $object->mdid) {
        // We have a real user, so we produce full links
        $values['subscriptions-manage'] = notifications_anonymous_url("notifications/destination/$account->mdid/manage");
        $values['unsubscribe-url-global'] =  notifications_anonymous_url("notifications/destination/$account->mdid/unsubscribe");
      }
      return $values;
  }
}

/**
 * Get link for anonymous subscriptions / destinations
 * 
 * @param $op
 *   Operation: subscribe, unsubscribe, manage, edit
 * @param $params
 *   Array of mixed parameters. Same as notifications_get_links() plus:
 *   - type = 'subscription' | 'destination'
 *   - oid = object id (sid, mdid)
 */
function notifications_anonymous_get_link($op, $params) {
  $params += array(
    'absolute' => TRUE,
  );
  // Diference subscription / destination
  switch ($op) {
    case 'subscribe':
      $elements = array(
        'anonymous',
        'subscribe',
        $params['type'],
        implode(',', array_keys($params['fields'])),
        implode(',', $params['fields'])     
      );
      break;
    case 'confirm':
    case 'edit':
    case 'manage':
    case 'delete':
    case 'unsubscribe': 
      $elements = array(
        'anonymous',
        $params['type'],
        $params['oid'],
        $op,
      );
      // Anonymous links are signed as default
      $params += array('signed' => TRUE);
      break;
  }
  return _notifications_get_link($elements, $params);
}

/**
 * Get raw links to manage subscription / destination
 */
function _notifications_anonymous_manage_links($type, $object) {
  $links = array();
  $params = array(
    'absolute' => TRUE,
    'signed' => TRUE,
    'type' => $type, // subscription / destination
  );
  if ($type == 'destination') {
    $params['oid'] = $params['mdid'] = $object->mdid;
    $link_types = array(
      'manage' => t('Manage'),
      'edit' => t('Edit'),
      'delete' => t('Delete'),
    );
  }
  elseif ($type == 'subscription') {
    $params['oid'] = $params['sid'] = $object->sid;
    $link_types = array(
      'unsubscribe' => t('Unsubscribe'),
      'edit' => t('Edit'),
    );
  }
  foreach ($link_types as $op => $name) {
    if (_notifications_anonymous_access($type, $object, $op)) {
      $links[$op] = notifications_anonymous_get_link($op, $params);
      $links[$op]['title'] = $name;
    }
  }
  return $links;
}

/**
 * Check for object access
 */
function _notifications_anonymous_access($type, $object, $op) {
  if (function_exists($function = 'notifications_anonymous_' . $type . '_access')) {
    return $function($op, $object);
  }
}
/**
 * Get formatted links to manage subscription / destination
 */
function notifications_anonymous_manage_links($type, $object) {
  $items = array();
  foreach (_notifications_anonymous_manage_links($type, $object) as $link) {
    $items[] = l($link['title'], $link['href'], $link['options']);
  }
  return $items;
}

/**
 * Create signed URLs for all pages
 */
function notifications_anonymous_url($url, $options = array()) {
  $elements = explode('/' . $url);
  $options += array('absolute' => TRUE);
  $options['query']['signature'] =  _notifications_signature($elements);
  return url($url, $options);
}

/**
 * Implementation of notifications_hook()
 * 
 * Check access permissions to subscriptions
 */
function notifications_anonymous_notifications($op, &$arg0, $arg1 = NULL, $arg2 = NULL) {
  global $user;

  switch ($op) {
    case 'access':
      if (!$user->uid && $arg0 == 'subscription') {
        $account = $arg1;
        $subscription = $arg2;
        // Check flood control
        if (!flood_is_allowed('notifications_anonymous', variable_get('notifications_anonymous_hourly_threshold', 3))) {
          drupal_set_message(t("You cannot create more than %number subscriptions per hour. Please try again later.", array('%number' => variable_get('notifications_anonymous_hourly_threshold', 3))), 'warning');
          return array(FALSE);
        }      
      }
      break;   
  } 
}

/**
 * Send unsubscribe message
 */
function notifications_anonymous_message($type , $destination, $confirm = TRUE) {
  $message = new Stdclass();
  switch ($type) {
    case 'unsubscribe':
      $message->subject = t('Unsubscribe from !site_name', array('!site_name' => variable_get('site_name', 'Drupal')));
      if ($confirm) {
        $message->body = array(
          t('Click on this link or copy and paste it on your browser to confirm you want to unsubscribe.'),
          notifications_anonymous_url("notifications/destination/$destination->mdid/unsubscribe"),
        );
      }
      else {
        $message->body = t('You have been unsubscribed.');
      }
      break;
    case 'subscribe':
      $message->subject = t('Subscribe to !site_name', array('!site_name' => variable_get('site_name', 'Drupal')));
      $message->body = array(
        t('Click on this link or copy and paste it on your browser to confirm your subscription.'),
        notifications_anonymous_url("notifications/destination/$destination->mdid/subscribe"),
      );
  }
  return messaging_message_send_out($destination->address, $message, $destination->method);
}